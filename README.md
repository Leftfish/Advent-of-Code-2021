# Advent of Code 2021

Again I tried to find out how far I can make it in [Advent of Code](https://adventofcode.com/2021/). Results for previous editions:
* 2018: 9 days
* 2019: 13 days
* 2020: 25 days for the first time!

Again, I had no idea if I could devote enough time to solving puzzles and if my feeble skills could hold up against this year's tasks. It appeared tougher than last year, but **I made it through for the second year in a row**. I have to admit that I had some serious trouble with days 16 (part 2), 19, 21 (part 2) and 24. AoC community on Reddit helped a ton! I'm particularly proud of coming up with solutions to Days 6, 14, 15 and 18 on my own!

Things I **L**earned, **R**evised or **I**mproved at in 2021:

* [Day 1](01/d01.py): using zip (**R**) and list comprehensions in Python (**R**)
* [Day 2](02/d02.py): using complex numbers in Python (**L**)
* [Day 3](03/d03.py): basic set operations in Python (**R**), typing hints in Python (**I**) and operator module (**R**)
* [Day 4](04/d04.py): parsing strings (**R**)
* [Day 5](05/d05.py): using regular expressions (**R**) and drawing plots in matplotlib (**L**)
* [Day 6](06/d06.py): using deques (**R**)
* [Day 7](07/d07.py): Gauss's formula (**R**) and I got to know that statistics module is thing in Python (**L**)
* [Day 8](08/d08.py): set operations (**R**) and frozenset in Python (**L**)
* [Day 9](09/d09.py): using iterative BFS (**R**) and recursive DFS(**R**) to find islands in a 2D matrix (**L**)
* [Day 10](10/d10.py): using stacks (**R**)
* [Day 11](11/d11.py): some very basic OOP principles (**R**) but the code needs a lot of cleaning up
* [Day 12](12/d12.py): DFS (**I**) and "yield from" in Python (**L**)
* [Day 13](13/d13.py): slicing 2d NumPy arrays (**L**) and avoiding 2d arrays altogether thanks to dictionaries or sets (**I**)
* [Day 14](14/d14.py): that you don't actually have to store everything that you count (**I**)
* [Day 15](15/d15.py): Dijkstra's algorithm, finally! (**L**)
* [Day 16](16/d16.py): oooof, this was a tough one; managed to do part 1 without help - and learn a lot about recursion on the way (**L**), but only looking at another solution helped be represent the tree structure properly (**L**)
* [Day 17](17/d17.py): using regex to extract negative integers from string (**R**)
* [Day 18](18/d18.py): another tough day, lots of things I vaguely know about but never had a chance to implement: recursively parsing lists into binary trees (**L**), traversing trees in-order iteratively and recursively (**L**), finding predecessors and successors in a binary tree which is NOT a binary search tree (**L**)
* [Day 19](19/d19.py): done as next to last; made me learn a bit about vectors in 3D (**L**), as well as rotations and translations of sets of 3D points (**L**)
* [Day 20](20/d20.py): representing grids as dictionaries with default values (**I**)
* [Day 21](21/d21.py): dynamic programming (**I**) and using LRU_cache from functools (**L**)
* [Day 22](22/d22.py): a tough one again; figuring out how to think in 3D to represent cubes as ranges of points (**L**) wasn't that obvious, and I barely had contact with the inclusionâ€“exclusion principle (**L**) before
* [Day 23](23/d23.py): solved [part 1](23/part1.txt) of the puzzle by hand in about 5 minutes, then spent a couple of hours a day for half a week implementing the game rules for part 2, and then another hour or so to implement a simple Dijkstra search (**I**) and learn how to create hashable objects in Python (**L**)
* [Day 24](24/d24.xlsx): ooof, another tough nut to crack and without some writeups I would never had realized what was going on here; ended up solving it in [Excel](24/d24.xlsx) and learned a bunch about [translating code](24/d24_pseudocode.adv) (**L**) and using numbers as stacks (**L**) along the way
* [Day 25](25/d25.py): using sets and hashtables to represent grids (**R**)